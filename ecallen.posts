{:ecallen
 {:dd6bff92-8e31-11e5-acb0-ffbf3d8c2695dd6bff92-8e31-11e5-acb0-ffbf3d8c2695
  {:title "Bright Paper Werewolves",
   :author "CAllen",
   :post-timestamp "1447878296",
   :revision 0,
   :last-update "1447878296",
   :text
   "c'mon polluted eyeballs\n\nstop scouting out the field\n\njump up bright paper werewolves\n\nand everybody everywhere\n\nanyone can scratch\n\nand anyone can win\n\nso bring out another batch\n\nthey want to get out of here\n\nbut they can't find the exit\n\nthey cling to the cinema\n\nand they can't find security\n\nthen they finally got recognized\n\nso they left in obscurity and misery\n\n-Guided By Voices, Under the Bushes, Under the Stars"},
  :49d6c20c-a7db-4ab5-a807-66875ef32697
  {:title "Clojurescript/React Blog in 15 minutes",
   :author "ECAllen",
   :post-timestamp 1455640001330,
   :last-update 1455640001331,
   :revision 0,
   :text
   "### The Challenge\n\nI was listening to an excellent [podcast with Eric Normand](http://giantrobots.fm/172)  where he mentioned that the tooling around clojurescript was mature enough to recreate the famous [Ruby 15 minute blog engine](https://www.youtube.com/watch?v=Gzj723LkRJY). So I felt like mucking about with clojurescript and I was tired of my previous blog platform. Since I have been playing with react/reagent on other projects I decided to see how long it would take before I could get something useful up and running.\n\nI will create two projects: one for the fronted SPA (Single Page App) and another that will simply serve up blog posts using a data structure. Normally there would be one project to do both but I decided to separate them into two projects.\n\n#### The Solution\n\n##### Shape of the data\n\nFirst we need to decide on the shape of data structure that the SPA and the back-end  will share. The following should do:\n\n```clojure\n(def blog-posts\n  {:ecallen\n   {:UUID\n    {:title \"Bright Paper Werewolves\"\n     :author \"ECAllen\"\n     :post-timestamp \"some epoch time\"\n     :revision 0\n     :last-update \"some epoch time\"\n     :text \"...\" }}})\n```\n### Backend/Liberator REST server\n\nNow that we know what the data will look like, let's create a process to serve it up to the front end. At first it will only respond to a GET and deliver a simple map via transit using liberator.\n\nCreate the blog server using lein\n\n```shell\nlein new blog-server\n```\n\nAdd the needed plugins and libs to the project.clj.\n\n```clojure\n(defproject blog-server \"0.1.0-SNAPSHOT\"\n  :description \"server for blog posts\"\n  :url \"https://github.com/ECAllen/blog-server.git\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n  :dependencies [[org.clojure/clojure \"1.7.0\"]\n                 [liberator \"0.14.0\"]\n                 [compojure \"1.4.0\"]\n                 [io.clojure/liberator-transit \"0.3.0\"]\n                 [ring-transit \"0.1.4\"]\n                 [liberator \"0.14.0\"]\n                 [ring-cors \"0.1.7\"]\n                 [ring/ring-core \"1.4.0\"]\n                 [ring/ring-jetty-adapter \"1.4.0\"]\n                 [juxt/dirwatch \"0.2.3\"]\n                 [environ \"1.0.2\"]]\n  :ring {:handler blog-server.core/handler}\n  :main blog-server.core\n  :uberjar-name \"blog-server.jar\"\n  :profiles {:uberjar {:env {:production true}\n                       :aot :all\n                       :omit-source true}}\n :plugins [[lein-ring \"0.9.7\"]\n           [lein-environ \"1.0.2\"]])\n```\n\nNext code needs to be written to respond to a GET request and deliver the map to the browser. This is the minimal code to get that done.\n\n```clojure\n(ns blog-server.core\n  (:gen-class)\n  (:require\n   [liberator.core :as liber]\n   [clojure.pprint :as pp]\n   [compojure.core :as compj]\n   [compojure.route :as route]\n   [compojure.handler :as handler]\n   [compojure.response :as response]\n   [ring.middleware.params :as param]\n   [ring.middleware.cors :as cors]\n   [io.clojure.liberator-transit :as transit]\n   [ring.middleware.transit :as ring-transit]\n   [ring.adapter.jetty :refer [run-jetty]]\n   [clojure.string :as str]\n   [clojure.edn :as edn]\n   [juxt.dirwatch :refer [watch-dir]]\n   [environ.core :refer [env]])\n  (:import java.io.File))\n\n\n;; ======================\n;; Globals\n;; ======================\n\n(def blog-file (env :blog-file))\n(def blog-dir (env :blog-dir))\n(def port (Integer/parseInt (env :port)))\n\n;; ======================\n;; Persist\n;; ======================\n\n(defn read-file [file]\n  (edn/read-string (slurp file)))\n\n(defn save-file [data file append-mode]\n  (with-open [f (clojure.java.io/writer file :append append-mode)]\n    (pp/pprint @data f)))\n\n(defn get-posts [file]\n  (if (not (.exists (File. file)))\n    (save-file (atom {}) file true))\n  (atom (read-file file)))\n\n(def blog-posts (get-posts blog-file))\n\n(defn update-posts [event]\n  (let [file (-> event :file bean :path str)\n        action (:action event)]\n    (if (and (= action :modify) (= file blog-file))\n      (do\n        ; (prn \"debug\" event)\n        (reset! blog-posts (read-file blog-file))))))\n\n;; ======================\n;; Resources\n;; ======================\n(liber/defresource posts [userid]\n  :available-media-types [\"application/transit+json\"\n                          \"application/transit+msgpack\"\n                          \"application/json\"]\n  :handle-ok (fn [_] (get @blog-posts (keyword userid))))\n\n;; ======================\n;; Routes/Hndlers\n;; ======================\n\n(compj/defroutes main-routes\n  (compj/GET \"/posts/:userid\" [userid] (posts userid))\n  (route/not-found \"<h1>Page not found</h1>\"))\n\n(def handler\n  (-> main-routes\n      param/wrap-params\n      ring-transit/wrap-transit-params\n      (cors/wrap-cors :access-control-allow-origin [#\".*\"]\n                      :access-control-allow-methods [:get :post :options]\n                      :access-control-allow-headers [\"content-type\"])))\n\n;; ======================\n;; Main\n;; ======================\n\n(defn -main [ & args]\n  (run-jetty handler {:port port :join? false})\n  (watch-dir update-posts (clojure.java.io/file blog-dir)))\n\n```\nThe above code watches a file which holds the map for the blog post's data. When the file is updated the atom that holds the blog posts will be updated. Yes,most solutions would use a databases here, but that is overkill for my purposes. This is only a personal blog.\n\nOK now that's out of the way. Let's switch back to the front end and finish the minimum viable code there.\n\n### Frontend/React based SPA (Single Page App)\n\nFirst create a new reagent project named after a song from one of [my favorite bands](http://genius.com/Guided-by-voices-bright-paper-werewolves-lyrics):\n\n```shell\n> lein new reagent bright-paper-werewolves\n```\n\nadd the following libs to the project.clj file\n\n```clojure\n[cljs-ajax \"0.5.1\"]\n[markdown-clj \"0.9.85\"]\n[com.cognitect/transit-cljs \"0.8.232\"]\n```\n\nNow for the code. Most of the code below came from the lein reagent template.\n\n```clojure\n(ns bright-paper-werewolves.core\n    (:require [reagent.core :as reagent]\n              [reagent.ratom :as ratom]\n              [reagent.debug :as debug]\n              [reagent.session :as session]\n              [secretary.core :as secretary :include-macros true]\n              [accountant.core :as accountant]\n              [ajax.core :as ajax]\n              [markdown.core :refer [md->html]]\n              [cognitect.transit :as transit]))\n\n\n;; -------------------------\n;; Globals\n\n;; reagent vars for react\n(def posts (reagent/atom {}))\n(def p (ratom/run! (debug/println \"posts: \" @posts)))\n\n;; blog-server info, for now assume static\n;; --------------------------\n;; Testing\n;; (def server \"localhost\")\n;; (def port \"3000\")\n\n;; --------------------------\n;; Production\n(def server \"ecallen.com\")\n(def port \"4010\")\n\n(def userid \"ecallen\")\n\n;; -------------------------\n;;  AJAX\n\n;; error handler for debugging\n(defn error-handler [response]\n  (debug/println (str \"Error status: \" (:status response)))\n  (debug/println (str \"Status details: \" (:status-text response)))\n  (debug/println (str \"Failure: \" (:failure response)))\n  (if (contains? response :parse)\n    (debug/println (str \"Parse error: \" (:parse response)))\n    (debug/println (str \"Original Text: \" (:original-text response))))\n  (debug/println (str \"Error response: \" response)))\n\n(defn posts-handler [response]\n  (reset! posts {})\n  (swap! posts conj response))\n\n(defn ajax-get [url handler error-handler]\n  (ajax/GET url\n    {:handler posts-handler\n     :error-handler error-handler\n     :response-format :transit}))\n\n(defn get-posts []\n  (ajax-get (str \"http://\" server \":\" port \"/posts/\" userid) posts-handler error-handler))\n\n;; -------------------------\n;; Views\n\n(defn markdown-component [content]\n    [:div {:dangerouslySetInnerHTML\n           {:__html (-> content md->html)}}])\n\n(defn home-page []\n  [:div\n   [:h1 \"ECAllen\"]\n   (doall (for [k (keys (sort-by (comp :post-timestamp second) > @posts))]\n           ^{:key k}\n           [:section\n             [:h2 (get-in @posts [k :title])]\n             [:p (get-in @posts [k :post-timestamp])]\n             [:p (markdown-component (get-in @posts [k :text]))]]))])\n\n\n(defn current-page []\n  [:div [(session/get :current-page)]])\n\n;; -------------------------\n;; Routes\n\n(secretary/defroute \"/\" []\n  (session/put! :current-page #'home-page))\n\n;; -------------------------\n;; Initialize app\n(get-posts)\n\n(defn mount-root []\n  (reagent/render [current-page] (.getElementById js/document \"app\")))\n\n(defn init! []\n  (accountant/configure-navigation!)\n  (accountant/dispatch-current!)\n  (mount-root))\n```\n\n### Style the page\n\nWe are going to make it look nice by adding [tufte.css]( https://edwardtufte.github.io/tufte-css/)\n\nClone the tufte repo then copy the needed files to the clojurescript project\n\n```shell\ncp tufte.css ~/projects/bright_paper_werewolves/resources/public/css/\ncp -r et-book ~/projects/bright_paper_werewolves/resources/public/css/\n```\nEdit the hander file to use the new css file src/clj/bright_paper_werewolves/handler.clj\n\nMake the include-css line look like the following:\n\n```clojure\n(include-css (if (env :dev) \"css/tufte.css\" \"css/tufte.css\"))\n```\n\n### Adding blog posts\n\nFor now I am keeping the posts in a file under git. When I want to CRUD posts I simply update the file and then do the git pull on the server. The blog server will watch the file and update the posts when it is modified. This is admittedly a very idiomatic process and it works for a personal blog.\n\n### Conclusions\n\nWas I able to do this in 15 minutes?\n\nNo. But I was able to do about 90% of it in 15 min. The remaining 10% took quite a bit longer but this was because I was using libraries that I had never used before and I was figuring things out. I don't have a lot of web programming experience with clojure so I was surprised at how much I was able to do in a short time.\n\nIs my solution as robust as the Ruby 15 minute blog?\n\nNo but it is mainly due to my inexperience and because I was creating something mainly for myself, so I don't care if it is idiomatic to my work-flow.\n\nDo I think a 15 minute clojurescript solution could be created?\n\nAbsolutely, but it might take 20 minutes. The main hurdle in the clojure(script) ecosystem is understanding all the libraries. You don't have this friction in the Rails framework but I am certain the equivalent work could be accomplished. Honestly if you created the right lein templates or utilized boot the process could be incredibly streamlined.\n\n### github pages\n\nhttps://github.com/ECAllen/blog-server\n\nhttps://github.com/ECAllen/bright_paper_werewolves\"\n"},
  :8d74edd2-f634-46e7-bdd2-485b851aabf5
  {:title "Adding Highlight.js to the Blog Engine",
   :author "ECAllen",
   :post-timestamp 1455739485985,
   :last-update 1455739485985,
   :revision 0,
   :text
   "### Adding highlight.js to the Blog\n\nPer the community the easist way to get javascript libraries into your project is to use [cljsjs](http://cljsjs.github.io/). However I tired to use it and could not get it to work quickly. I looked at the code and saw that it is basically downloading a external zip. It looked too complicated for what it was doing. I decided to go with externs instead.\n\nThe basic trick is to integrate the highlighting in the React life cycle. Luckily there is a reagent cookbook recipe on this already. It can be found [here](https://github.com/reagent-project/reagent-cookbook/tree/master/recipes/markdown-editor). I took the recipe and simplified it a little.\n\nFirst the project.clj file needs to be updated.\n\nAdd dommy in the dependencies:\n\n```clojure\n[prismatic/dommy \"1.1.0\"]\n```\n\nThe :cljsbuild map will need to be updated with :externs. Mine looks like this:\n\n```clojure\n:cljsbuild {:builds {:app {:source-paths [\"src/cljs\" \"src/cljc\"]\n                           :compiler {:output-to \"target/cljsbuild/public/js/app.js\"\n                                      :output-dir \"target/cljsbuild/public/js/out\"\n                                      :asset-path   \"js/out\"\n                                      :optimizations :none\n                                      :pretty-print  true\n                                      :externs [\"externs/syntax.js\"]}}}}\n```\n\nAdd a extern file: externs/syntax.js with the following contents:\n\n```javascript\n\nvar hljs = {};\nhljs.highlight = function (name, value, ignore_illegals, continuation) {};\nhljs.highlightAuto = function (text, languageSubset) {};\nhljs.fixMarkup = function (value) {};\nhljs.highlightBlock = function (block) {};\nhljs.configure = function (user_options) {};\nhljs.initHighlighting = function () {};\nhljs.initHighlightingOnLoad = function () {};\nhljs.registerLanguage = function (name, language) {};\nhljs.listLanguages = function () {};\nhljs.getLanguage = function (name) {};\nhljs.inherit = function (parent, obj) {};\n\n```\n\nThe original recipe used this function to highlight code:\n\n```clojure\n(defn highlight-code [html-node]\n  (let [nodes (.querySelectorAll html-node \"pre code\")]\n    (loop [i (.-length nodes)]\n      (when-not (neg? i)\n        (when-let [item (.item nodes i)]\n          (.highlightBlock js/hljs item))\n        (recur (dec i))))))\n```\n\nThis can be simplified by using the [dommy](https://github.com/plumatic/dommy) library. Here is the new fn:\n\n```clojure\n(defn highlight-code [html-node]\n  (let [nodes (sel [:pre :code])]\n    (doall (for [node nodes]\n               (.highlightBlock js/hljs node)))))\n```\n\nThen the projects existing markdown-component fn will change from:\n\n``` clojure\n(defn markdown-component [content]\n    [:div {:dangerouslySetInnerHTML\n           {:__html (-> content md->html)}\n```\n\nto this:\n\n```clojure\n(defn markdown-component [content]\n           [(with-meta\n              (fn []\n                [:div {:dangerouslySetInnerHTML\n                       {:__html (-> content md->html)}}])\n              {:component-did-mount\n                (fn [this]\n                  (let [node (reagent/dom-node this)]\n                    (highlight-code node)))})])\n```\n\nLast step is to update the handler.clj file to load the highlight.js css and js files.\n\n``` clojure\n(def loading-page\n  (html\n   [:html\n    [:head\n     [:meta {:charset \"utf-8\"}]\n     [:meta {:name \"viewport\"\n             :content \"width=device-width, initial-scale=1\"}]\n     (include-css \"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/agate.min.css\"\n                  (if (env :dev) \"css/tufte.css\" \"css/tufte.min.css\"))]\n    [:body\n     mount-target\n     (include-js\n      \"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js\"\n      \"js/app.js\")]]))\n```\n\nNote that the highlight css file has different styles available. The styles can be found on the highlight.js [demo page](https://highlightjs.org/static/demo/). \n"},
  :42b5e4e1-9312-4364-adb2-f12c79ab01b1
  {:title "Adding a menu to the blog engine",
   :author "ECAllen",
   :post-timestamp 1456779170031,
   :last-update 1456779170032,
   :revision 0,
   :text
   "### Adding a menu to the blog\n\nOK the blog is kind of plain. Also I would like to have different section. So I am going to add a simple top menu. It is a pretty straight forward process. I think the hardest part is understanding how the various parts of the reagent template interact with each other.   \n\nFirst create a css file named site.css in the resources/public/css dir:\n\n```css\nul.menu {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n    width: 100%;\n}\n\nli.menu {\n    display: inline;\n    float: left;\n}\n\nli.menu a.menu {\n    text-align: left;\n    border-left: 1px solid #bbb;\n    padding: 14px;\n    text-decoration: none;\n}\n```\nThe above is needed because the tufte.css has no styling for a menu.\n\nThen the handler.clj file needs to be updated to pull in this new css. Add the new css file as an arg to the include-css function.\n\n``` clojure\n(include-css\n (if (env :dev) \"css/tufte.css\" \"css/tufte.min.css\")\n  ...\n \"css/site.css\")\n```\n\nThese two functions will actually create the menu and will go into the core.cljs file.\n\n```clojure\n(defn menu-link [url txt]\n  [:a {:href url :class \"menu\"} txt])\n\n(defn top-menu []\n    [:ul {:class \"menu\"}\n     [:li {:class \"menu\"}\n      ;; add menu items here\n      (menu-link \"/\" \"Blog\")\n      (menu-link \"/marginalia\" \"Marginalia\")]])\n```\n\nHere is an example of how the function is used to create the top menu for the home page:\n\n```clojure\n(defn home-page []\n  [:div\n    [:div {:class \"fullwidth\"}\n      (top-menu)]\n    [:div\n      [:h1 \"ECAllen\"\n      ...\n```\n\nThat's it.\n"}}}
