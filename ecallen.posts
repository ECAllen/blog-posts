{:ecallen
 {:dd6bff92-8e31-11e5-acb0-ffbf3d8c2695dd6bff92-8e31-11e5-acb0-ffbf3d8c2695
  {:title "Bright Paper Werewolves",
   :author "CAllen",
   :post-timestamp "1447878296",
   :revision 0,
   :last-update "1447878296",
   :text
   "c'mon polluted eyeballs\n\nstop scouting out the field\n\njump up bright paper werewolves\n\nand everybody everywhere\n\nanyone can scratch\n\nand anyone can win\n\nso bring out another batch\n\nthey want to get out of here\n\nbut they can't find the exit\n\nthey cling to the cinema\n\nand they can't find security\n\nthen they finally got recognized\n\nso they left in obscurity and misery\n\n-Guided By Voices, Under the Bushes, Under the Stars"},
  :e43039ec-4e8e-4210-8f31-8fdd30261566
  {:title "Deploying Blog",
   :author "ECAllen",
   :post-timestamp 1453227655708,
   :last-update 1453227655709,
   :revision 0,
   :text
   "Deployment\n\nFirst create the jar files for the client and server\n\nedit bright-paper-werewolves/src/clj/bright-paper-werewolves/server.clj\n\nchange the port to 4000\n\nlein do clean, uberjar\n\n\ncreate a uberjar for the blog server\n\nchange the port to 4010\n\nlein do clean, uberjar\n\nDeploy the jars to a web server. At this point there are many ways to get the server running (nginx, tomcat etc...) so I wont go into particulars. You also might want to look into heroku as an option.\n\nI am going to create a systemd service file for each app then configure nginx\n\nCreating the systemd service (unit) files\n\n\n[Unit]\nDescription=Blog server\nAfter=syslog.target\nAfter=network.target\n\n[Service]\nType=simple\nUser=blog\nExecStart=\n\n# Give a reasonable amount of time for the server to start up/shut down\nTimeoutSec=300\n\n[Install]\nWantedBy=multi-user.target\n"}}}
{:ecallen
 {:dd6bff92-8e31-11e5-acb0-ffbf3d8c2695dd6bff92-8e31-11e5-acb0-ffbf3d8c2695
  {:title "Bright Paper Werewolves",
   :author "CAllen",
   :post-timestamp "1447878296",
   :revision 0,
   :last-update "1447878296",
   :text
   "c'mon polluted eyeballs\n\nstop scouting out the field\n\njump up bright paper werewolves\n\nand everybody everywhere\n\nanyone can scratch\n\nand anyone can win\n\nso bring out another batch\n\nthey want to get out of here\n\nbut they can't find the exit\n\nthey cling to the cinema\n\nand they can't find security\n\nthen they finally got recognized\n\nso they left in obscurity and misery\n\n-Guided By Voices, Under the Bushes, Under the Stars"},
  :bd011baf-e0df-44db-9fbc-c3750df1e6ca
  {:title "Clojurescript Blog in 15 minutes",
   :author "ECAllen",
   :post-timestamp 1453998093688,
   :last-update 1453998093689,
   :revision 0,
   :text
   "#### The Challenge\n\nI was listening to an excellent [podcast with Eric Normand](http://giantrobots.fm/172)  where he mentioned that the tooling around clojurescript was mature enough to recreate the famous [Ruby 15 minute blog engine](https://www.youtube.com/watch?v=Gzj723LkRJY). So I felt like mucking about with clojurescript and I was tired of my previous blog platform. Since I have been playing with react/reagent on other projects I decided to see how long it would take before I could get something useful up and running.\n\nI will create two projects: one for the fronted SPA (Single Page App) and another that will simply serve up blog posts using a data structure. Normally there would be one project to do both but I decided to separate them into two projects.\n\n#### The Solution\n\n##### Shape of the data\n\nFirst we need to decide on the shape of data structure that the SPA and the back-end  will share. The following should do:\n\n```clojure\n(def blog-posts\n  {:ecallen\n   {:UUID\n    {:title \"Bright Paper Werewolves\"\n     :author \"ECAllen\"\n     :post-timestamp \"some epoch time\"\n     :revision 0\n     :last-update \"some epoch time\"\n     :text \"...\" }}})\n```\n##### Backend/Liberator REST server\n\nNow that we know what the data will look like, let's create a process to serve it up to the front end. At first it will only respond to a GET and deliver a simple map via transit using liberator.\n\nCreate the blog server using lein\n\n```shell\nlein new blog-server\n```\n\nAdd the needed plugins and libs to the project.clj.\n\n```clojure\n(defproject blog-server \"0.1.0-SNAPSHOT\"\n  :description \"server for blog posts\"\n  :url \"https://github.com/ECAllen/blog-server.git\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n  :dependencies [[org.clojure/clojure \"1.7.0\"]\n                 [liberator \"0.14.0\"]\n                 [compojure \"1.4.0\"]\n                 [io.clojure/liberator-transit \"0.3.0\"]\n                 [ring-transit \"0.1.4\"]\n                 [liberator \"0.14.0\"]\n                 [ring-cors \"0.1.7\"]\n                 [ring/ring-core \"1.4.0\"]\n                 [ring/ring-jetty-adapter \"1.4.0\"]\n                 [juxt/dirwatch \"0.2.3\"]\n                 [environ \"1.0.1\"]]\n\n  :ring {:handler blog-server.core/handler}\n  :main blog-server.core\n  :plugins [[lein-ring \"0.8.11\"]\n            [lein-environ \"1.0.1\"]]\n  :profiles {:uberjar {:aot :all\n                       :env {:production true}}})\n```\n\nNext code needs to be written to respond to a GET request and deliver the map to the browser. This is the minimal code to get that done.\n\n```clojure\n(ns blog-server.core\n  (:gen-class)\n  (:require\n   [liberator.core :as liber]\n   [clojure.pprint :as pp]\n   [compojure.core :as compj]\n   [compojure.route :as route]\n   [compojure.handler :as handler]\n   [compojure.response :as response]\n   [ring.middleware.params :as param]\n   [ring.middleware.cors :as cors]\n   [io.clojure.liberator-transit :as transit]\n   [ring.middleware.transit :as ring-transit]\n   [ring.adapter.jetty :refer [run-jetty]]\n   [clojure.string :as str]\n   [clojure.edn :as edn]\n   [juxt.dirwatch :refer (watch-dir)]\n   [environ.core :refer [env]])\n  (:import java.io.File))\n\n;; ======================\n;; Globals\n;; ======================\n\n(def blog-file (env :blog-file))\n\n(def blog-dir (env :blog-dir))\n\n(def port (env :port))\n\n;; ======================\n;; Persist\n;; ======================\n\n(defn read-file [file]\n  (edn/read-string (slurp file)))\n\n(defn save-file [data file append-mode]\n  (with-open [f (clojure.java.io/writer file :append append-mode)]\n    (pp/pprint @data f)))\n\n(defn get-posts [file]\n  (if (not (.exists (File. file)))\n    (save-file (atom {}) file true))\n  (atom (read-file file)))\n\n(def blog-posts (get-posts blog-file))\n\n(defn update-posts [event]\n  (let [file (-> event :file bean :path str)\n        action (:action event)]\n      (if (and (= action :modify) (= file blog-file))\n          (do (reset! blog-posts (read-file blog-file))))))\n\n(watch-dir update-posts (clojure.java.io/file blog-dir))\n\n;; ======================\n;; Resources\n;; ======================\n(liber/defresource posts [userid]\n  :available-media-types [\"application/transit+json\"\n                          \"application/transit+msgpack\"\n                          \"application/json\"]\n  :handle-ok (fn [_] (get @blog-posts (keyword userid))))\n\n;; ======================\n;; Routes/Hndlers\n;; ======================\n\n(compj/defroutes main-routes\n  (compj/GET \"/posts/:userid\" [userid] (posts userid))\n  (route/not-found \"<h1>Page not found</h1>\"))\n\n(def handler\n  (-> main-routes\n      param/wrap-params\n      ring-transit/wrap-transit-params\n      (cors/wrap-cors :access-control-allow-origin [#\".*\"]\n                      :access-control-allow-methods [:get :post :options]\n                      :access-control-allow-headers [\"content-type\"])))\n\n;; ======================\n;; Main\n;; ======================\n\n(defn -main [& args]\n  (run-jetty handler {:port port :join? false}))\n```\nThe above code watches a file which holds the map for the blog post's data. When the file is updated the atom that holds the blog posts will be updated. Yes,most solutions would use a databases here, but that is overkill for my purposes. This is only a personal blog.\n\nOK now that's out of the way. Let's switch back to the front end and finish the minimum viable code there.\n\n##### Frontend/React based SPA (Single Page App)\n\nFirst create a new reagent project named after a song from one of [my favorite bands](http://genius.com/Guided-by-voices-bright-paper-werewolves-lyrics):\n\n```shell\n> lein new reagent bright-paper-werewolves\n```\n\nadd the following libs to the project.clj file\n\n```clojure\n[cljs-ajax \"0.5.1\"]\n[markdown-clj \"0.9.85\"]\n[com.cognitect/transit-cljs \"0.8.232\"]\n```\n\nNow for the code. Most of the code below came from the lein reagent template.\n\n```clojure\n(ns bright-paper-werewolves.core\n    (:require [reagent.core :as reagent]\n              [reagent.ratom :as ratom]\n              [reagent.debug :as debug]\n              [reagent.session :as session]\n              [secretary.core :as secretary :include-macros true]\n              [accountant.core :as accountant]\n              [ajax.core :as ajax]\n              [markdown.core :refer [md->html]]\n              [cognitect.transit :as transit]))\n\n\n;; -------------------------\n;; Globals\n\n;; reagent vars for react\n(def posts (reagent/atom {}))\n(def p (ratom/run! (debug/println \"posts: \" @posts)))\n\n;; blog-server info, for now assume static\n;; --------------------------\n;; Testing\n;; (def server \"localhost\")\n;; (def port \"3000\")\n\n;; --------------------------\n;; Production\n(def server \"ecallen.com\")\n(def port \"4010\")\n\n(def userid \"ecallen\")\n\n;; -------------------------\n;;  AJAX\n\n;; error handler for debugging\n(defn error-handler [response]\n  (debug/println (str \"Error status: \" (:status response)))\n  (debug/println (str \"Status details: \" (:status-text response)))\n  (debug/println (str \"Failure: \" (:failure response)))\n  (if (contains? response :parse)\n    (debug/println (str \"Parse error: \" (:parse response)))\n    (debug/println (str \"Original Text: \" (:original-text response))))\n  (debug/println (str \"Error response: \" response)))\n\n(defn posts-handler [response]\n  (reset! posts {})\n  (swap! posts conj response))\n\n(defn ajax-get [url handler error-handler]\n  (ajax/GET url\n    {:handler posts-handler\n     :error-handler error-handler\n     :response-format :transit}))\n\n(defn get-posts []\n  (ajax-get (str \"http://\" server \":\" port \"/posts/\" userid) posts-handler error-handler))\n\n;; -------------------------\n;; Views\n\n(defn markdown-component [content]\n    [:div {:dangerouslySetInnerHTML\n           {:__html (-> content md->html)}}])\n\n(defn home-page []\n  [:div\n   [:h1 \"ECAllen\"]\n   (doall (for [k (keys (sort-by (comp :post-timestamp second) > @posts))]\n           ^{:key k}\n           [:section\n             [:h2 (get-in @posts [k :title])]\n             [:p (get-in @posts [k :post-timestamp])]\n             [:p (markdown-component (get-in @posts [k :text]))]]))])\n\n\n(defn current-page []\n  [:div [(session/get :current-page)]])\n\n;; -------------------------\n;; Routes\n\n(secretary/defroute \"/\" []\n  (session/put! :current-page #'home-page))\n\n;; -------------------------\n;; Initialize app\n(get-posts)\n\n(defn mount-root []\n  (reagent/render [current-page] (.getElementById js/document \"app\")))\n\n(defn init! []\n  (accountant/configure-navigation!)\n  (accountant/dispatch-current!)\n  (mount-root))\n```\n\n###### Style the page\n\nWe are going to make it look nice by adding [tufte.css]( https://edwardtufte.github.io/tufte-css/)\n\nClone the tufte repo then copy the needed files to the clojurescript project\n\n```shell\ncp tufte.css ~/projects/bright_paper_werewolves/resources/public/css/\ncp -r et-book ~/projects/bright_paper_werewolves/resources/public/css/\n```\nedit the hander file to use the new css file src/clj/bright_paper_werewolves/handler.clj\n\nmake the include-css line look like the following:\n\n```clojure\n(include-css (if (env :dev) \"css/tufte.css\" \"css/tufte.css\"))\n```\n\n##### Adding blog posts\n\nFor now I am keeping the posts in a file under git. When I want to CRUD posts I simply update the file and then do the git pull on the server. The blog server will watch the file and update the posts when it is modified. This is admittedly a very idiomatic process and it works for a personal blog.\n\n#### Conclusions\n\nWas I able to do this in 15 minutes?\n\nNo. But I was able to do about 90% of it in 15 min. The remaining 10% took quite a bit longer but this was because I was using libraries that I had never used before and I was figuring things out. I don't have a lot of web programming experience with clojure so I was surprised at how much I was able to do in a short time.\n\nIs my solution as robust as the Ruby 15 minute blog?\n\nNo but it is mainly due to my inexperience and because I was creating something mainly for myself, so I don't care if it is idiomatic to my work-flow.\n\nDo I think a 15 minute clojurescript solution could be created?\n\nAbsolutely, but it might take 20 minutes. The main hurdle in the clojure(script) ecosystem is understanding all the libraries. You don't have this friction in the Rails framework but I am certain the equivalent work could be accomplished. Honestly if you created the right lein templates or utilized boot the process could be incredibly streamlined. \n\n#### github pages\n\nhttps://github.com/ECAllen/blog-server\n\nhttps://github.com/ECAllen/bright_paper_werewolves\"\n"}}}
